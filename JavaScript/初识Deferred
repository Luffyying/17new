<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>deferred对象</title>
	<link rel="stylesheet" href="">
	<script src="jquery.min.js"></script>
</head>
<body>
	<span>传统的 jQuery的ajax写法</span>
	<script>
		$.ajax({
			url:'test.html',
			success:function(){

			},
			error:function(){

			}
		})
		// 如果有一个很耗时的操作，我们希望在一个回调函数中执行后面的代码，其实deferred就是起这样作用的
		$.when($.ajax('test.html'),$.ajax('test2.html'))
		.done(function(){
			alert();
		}).fail(function(){
			alert();
		})
		//此时在函数wait()中就是一个耗时的操作，但仅仅是一个普通的函数,但这样的写法是无法起到回调的作用的，因为
		//$.when()的参数只能是deferred对象
		var wait = function(){
			var t = function(){
				console.log('over');
				
			}
			setTimeout(t,5000);
		}
		$.when(wait()).done().fail();

		//将wait()改写
		var a = $.Deferred();
		var wait = function(a){
			var t = function(){
				console.log('over');
				a.resolve();
				// 改变deferred对象的执行状态,当执行 a.resolve()的时候，任何通过deferred.then或者deferred.done添加的callback
				// 都会被调用,回调函数的执行顺序和被添加的顺序是一样的，传递给 deferred.resolve() 的 args 参数，会传给每个回调函数。当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 .resolve()的参数
			}
			setTimeout(t,5000);
			return a;
		}
		$.wait(a).done().fail();


		/*详细说明deferred的三种状态：   

			未完成，已完成，已失败
			deferred.resolve() 由未完成到已完成
			deferred.reject() 由未完成到已失败

		*/
		// 这时候如果这样写
		$.wait(a).done().fail();
		a.resolve();
		//这时候了末尾的a.resolve()改变了a 的状态，导致done()方法立刻执行，so 引出deferred.promise(),这个对象只返回和状态，后者只开放与改变执行状态无关的方法，从而使得deferred对象在外部不可随意改变

		//再次改写wait()
		var wait = function(a){
			var t = function(){
				console.log('over');
				a.resolve();
				// 改变deferred对象的执行状态,当执行 a.resolve()的时候，任何通过deferred.then或者deferred.done添加的callback
				// 都会被调用,回调函数的执行顺序和被添加的顺序是一样的，传递给 deferred.resolve() 的 args 参数，会传给每个回调函数。当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给 .resolve()的参数
			}
			setTimeout(t,5000);
			return a.promise();
		}

		//but...........,有一个更好的办法，将deferred对象变成wait()函数的内部对象
		var wait= function(){

			var a = $.Deferred();
			var test = function(){
				console.log('----');
				a.resolve();
			}
			setTimeout(test,5000);
			return a.promise();
		}

		//还有方法防止执行状态被改变，利用deferred对象的构造函数
		$.Deferred(wait).then();

		//maybe the last one

		var a = $.Deferred();
		var wait = function(a){
			var test = function(){
				console.log('----');
				a.resolve();
			}
			setTimeout(test,5000);
			
		}
		a.promise(wait);//在wait对象上部署Deferred接口
		wait.then();
		wait(a);
		//$.when() 为多个操作指定回调，$.then()就是$.done()和$.fail()合在一起写的

		//deferred 主要解决回调函数的部署，它与$.ajax的设计各有不同


	</script>
</body>
</html>
